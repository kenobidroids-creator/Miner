<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gem Miner - Persistent World</title>
    <style>
        canvas { 
            background: #000; display: block; margin: 0 auto; border: 4px solid #444; 
            cursor: crosshair; max-width: 100%; height: auto; -webkit-touch-callout: none; -webkit-user-select: none; touch-action: pan-y; image-rendering: pixelated; image-rendering: crisp-edges;
        }
        body { 
            background: #111; color: white; font-family: sans-serif; text-align: center; 
            margin: 0; padding: 10px; touch-action: manipulation; touch-action: pan-y;
        }
        .toolbar { 
            background: #222; padding: 10px; margin-bottom: 10px; border-radius: 8px; 
            border: 1px solid #444; display: flex; justify-content: center; flex-wrap: wrap; gap: 5px;
        }
        .canvas-container {
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            overflow: hidden;
            touch-action: pan-y;
        }
        .tool-btn { 
            padding: 10px 20px; font-weight: bold; cursor: pointer; border: 2px solid transparent; 
            border-radius: 4px; margin: 0 5px; background: #333; color: white;
        }
        .active-tool { border-color: #f1c40f; background: #444; color: #f1c40f; }
        .stats { margin: 10px 0; font-size: 1.1rem; font-weight: bold; }
        button.action { 
            background: #27ae60; color: white; border: none; padding: 12px 15px; 
            border-radius: 4px; cursor: pointer; font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Deep Miner: Level <span id="lvlDisplay">1</span></h1>
    
    <div class="toolbar">
    <button id="mineTool" class="tool-btn active-tool" onclick="setTool('mine')">‚õèÔ∏è MINE / CLIMB</button>
    <button id="ladderTool" class="tool-btn" onclick="setTool('ladder')">ü™ú PLACE LADDER (<span id="matDisplay">5</span>)</button>
    <button id="cargoTool" class="tool-btn" onclick="setTool('cargo')">üì¶ CARGO / DROP</button>
    </div>

    <div class="stats">
        Gold: $<span id="goldDisplay">0</span> | 
        Cargo: <span id="cargoDisplay">0</span>/<span id="maxDisplay">10</span> | 
        Depth: <span id="depthDisplay">0</span>
    </div>
    
    <div class="canvas-container">
        <canvas id="gameCanvas" width="400" height="500"></canvas>
    </div>

    <button onclick="toggleMap()" style="position:fixed; bottom:20px; left:20px; z-index:1001; padding:10px; background:#444; color:white; border:2px solid #666; border-radius:5px;">üó∫Ô∏è MAP</button>

    <div id="mapContainer" style="display:none; position:fixed; bottom:70px; left:20px; width:120px; height:180px; background:rgba(0,0,0,0.8); border:2px solid #f1c40f; z-index:1000; overflow:hidden;">
    <canvas id="mapCanvas" width="120" height="600"></canvas>
    </div>
    
    <div class="toolbar">
        <button class="action" onclick="buyUpgrade('cargo')">Cargo +5 ($100)</button>
        <button class="action" onclick="buyUpgrade('drill')">Drill +1 ($150)</button>
        <button class="action" onclick="buyUpgrade('ladders')">Buy 5 Ladders ($50)</button>
        <button class="action" onclick="buyUpgrade('light')">Flashlight +1 ($200)</button> </div>
        <button onclick="localStorage.clear(); location.reload();" style="background:red; color:white;">HARD RESET GAME</button>
    </div>

    <div id="dropModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1000; justify-content:center; align-items:center;">
    <div style="background:#222; padding:20px; border:4px solid #444; border-radius:8px; text-align:center; width:280px; font-family:sans-serif;">
        <h3 style="margin-top:0; color:#f1c40f;">DROP CARGO</h3>
        <div id="dropInputsContainer" style="margin-bottom:15px; text-align:left;">
            </div>
        <div style="display:flex; gap:10px; justify-content:center;">
            <button class="action" onclick="confirmDrop()">DROP ALL SELECTED</button>
            <button class="action" style="background:#c0392b;" onclick="closeDropModal()">CANCEL</button>
        </div>
    </div>
</div>

<div id="saleModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:1100; justify-content:center; align-items:center;">
    <div style="background:#222; padding:20px; border:4px solid #f1c40f; border-radius:8px; text-align:center; width:280px; font-family:'Courier New', monospace;">
        <h2 style="color:#f1c40f; margin-top:0;">HAUL SOLD!</h2>
        <div id="saleBreakdown" style="text-align:left; margin:15px 0; line-height:1.6;">
            </div>
        <hr style="border:1px solid #444;">
        <h3 style="margin-bottom:20px;">TOTAL: <span id="totalSaleVal" style="color:#2ecc71;">$0</span></h3>
        <button class="action" onclick="closeSaleModal()" style="width:100%;">CONTINUE</button>
    </div>
</div>

<script>
// --- CONFIG ---
const TILE_SIZE = 40;
const COLS = 10;
const ROWS = 60; 
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let manualOffsetY = 0;
let isManualScrolling = false;
let scrollTimeout;

// --- SPRITE ---
const spriteImg = new Image();
spriteImg.src = 'miner_spritesheet.png'; // Path to your saved image
const ladderSprite = new Image();
ladderSprite.src = 'ladder_tile.png'; // Updated to match your file name

// -- WORLD TILE TEXTURES --
const tileSprite = new Image();
tileSprite.src = 'tile_texture.png'; // Ensure this matches your filename

// --- STATE ---
let player = JSON.parse(localStorage.getItem('miner_ladder_v2')) || {
    x: 5, y: 0, gold: 100, cargo: 0, maxCargo: 10, 
    cargoValue: 0, // Add this to track the $ inside your bag
    level: 1, drillPower: 1, ladders: 5, lightRadius: 3,
    facing: 1,      // 1 for Right, -1 for Left
    state: 'idle',  // 'idle', 'walk', 'mine', 'climb'
    frame: 0,        // For simple animation cycling
    goldCount: 0,
    gemCount: 0,
    dirtCount: 0,
    queuedMine: null,
};
let world = [];
let currentTool = 'mine';
let target = null;
let currentPath = []; // Stores the actual list of steps to take
let touchStartX = 0;
let touchStartY = 0;
const SCROLL_THRESHOLD = 10; // Pixels moved before it counts as a scroll


// --- PERSISTENCE ---
function save() {
    localStorage.setItem('miner_ladder_v2', JSON.stringify(player));
    localStorage.setItem('miner_world_data', JSON.stringify(world));
}

function initLevel() {
    const savedWorld = localStorage.getItem('miner_world_data');
    if (savedWorld) {
        world = JSON.parse(savedWorld);
    } else {
        world = [];
        let hpMult = player.level || 1; 

        for (let y = 0; y < ROWS; y++) {
            world[y] = [];
            for (let x = 0; x < COLS; x++) {
                let type = 'dirt';
                let rand = Math.random();

                // 1. Determine Type
                if (y === 0) {
                    type = 'air';
                } else if (y === ROWS - 1) {
                    type = 'bedrock';
                } else if (rand < 0.05) {
                    type = 'gem';  // 5% chance for Gems
                } else if (rand < 0.15) {
                    type = 'gold'; // 10% chance for Gold (0.05 to 0.15 range)
                }

                // 2. Determine HP based on Type
                let baseHP = 1;
                if (type === 'gem') baseHP = 3;
                else if (type === 'gold') baseHP = 2; // Gold takes 2 hits
                else if (type === 'bedrock') baseHP = 999;
                
                let totalHP = baseHP * hpMult;
                
                world[y][x] = { 
                    type, 
                    mined: (type === 'air'), 
                    hasLadder: false, 
                    hp: totalHP,    
                    maxHP: totalHP  
                };
            }
        }
        save();
        updateMiniMap();
    }
    updateUI();
}

// --- TOOLS & INPUT ---
function setTool(tool) {
    currentTool = tool;
    document.getElementById('mineTool').className = 'tool-btn' + (tool === 'mine' ? ' active-tool' : '');
    document.getElementById('ladderTool').className = 'tool-btn' + (tool === 'ladder' ? ' active-tool' : '');
    document.getElementById('cargoTool').className = 'tool-btn' + (tool === 'cargo' ? ' active-tool' : '');
}

// --- NEW STATE FOR PATHFINDING ---
// Change 'target' to 'goal' to handle the persistent path
let goal = null;

function handleInput(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mouseX = (clientX - rect.left) * scaleX;
    const mouseY = (clientY - rect.top) * scaleY;
    
    const offsetY = Math.max(0, (player.y * TILE_SIZE) - canvas.height / 2);
    let tx = Math.floor(mouseX / TILE_SIZE);
    let ty = Math.floor((mouseY + offsetY) / TILE_SIZE);

    if (ty < 0 || ty >= ROWS || tx < 0 || tx >= COLS) return;

    // --- LADDER TOOL: PLACE OR DISMANTLE ---
    if (currentTool === 'ladder') {
        const targetTile = world[ty][tx];
        
        // DISMANTLE: If there is a ladder, pick it back up
        if (targetTile.hasLadder) {
            targetTile.hasLadder = false;
            player.ladders++; // Return the item to inventory
            save();
            updateMiniMap(); 
            updateUI();
        } 
        // PLACE: If it's empty space and you have ladders, place one
        else if (targetTile.mined && player.ladders > 0) {
            targetTile.hasLadder = true;
            player.ladders--;
            save();
            updateMiniMap(); 
            updateUI();
        }
        return; // Stop here so we don't try to move/mine while placing ladders
    }

   // --- CARGO TOOL: DROP OR PICK UP CRATE ---
if (currentTool === 'cargo') {
    const targetTile = world[ty][tx];
    
    // DROP: Click your own tile to trigger the modal
    if (tx === player.x && ty === player.y && player.cargo > 0) {
        if (!targetTile.hasCrate) {
            openDropModal(); // Open the new window
        }
        return;
    }

    // PICK UP: Click a tile with a crate to put its contents back in bag
    if (targetTile.hasCrate && player.cargo < player.maxCargo) {
    let space = player.maxCargo - player.cargo;
    let contents = targetTile.crateContents || { dirt: targetTile.crateAmount, gold: 0, gem: 0 };
    
    // Take Gems first (highest value), then Gold, then Dirt
    ['gem', 'gold', 'dirt'].forEach(type => {
        let countKey = type + 'Count';
        let val = (type === 'gem' ? 100 : (type === 'gold' ? 25 : 5));
        
        let toTake = Math.min(contents[type] || 0, space);
        if (toTake > 0) {
            contents[type] -= toTake;
            player[countKey] = (player[countKey] || 0) + toTake;
            player.cargo += toTake;
            player.cargoValue += (toTake * val);
            space -= toTake;
            targetTile.crateAmount -= toTake;
        }
    });

    if (targetTile.crateAmount <= 0) targetTile.hasCrate = false;
    save(); updateMiniMap(); updateUI();
    return;
}
}

    // --- MINING & MOVEMENT ---
    if (!world[ty][tx].mined) {
    // If we are already next to it, mine immediately
    if (Math.abs(tx - player.x) <= 1 && Math.abs(ty - player.y) <= 1) {
        if (player.cargo < player.maxCargo) {
            mineBlock(tx, ty);
            currentPath = [];
            player.queuedMine = null; // Clear queue if acted upon
        } else {
            blockedMessage = "CARGO FULL!";
            blockedTimer = 60;
        }
        return;
    } else {
        // NEW: If too far, queue this block to be mined upon arrival
        player.queuedMine = { x: tx, y: ty };
    }
} else {
    // If clicking empty space, clear the queue
    player.queuedMine = null;
}

    // Pathfinding trigger for movement
    currentPath = findPath(player.x, player.y, tx, ty);
}

function findPath(startX, startY, targetX, targetY) {
    let queue = [[{x: startX, y: startY}]];
    let visited = new Set([`${startX},${startY}`]);

    while (queue.length > 0) {
        let path = queue.shift();
        let curr = path[path.length - 1];

        // Success: Reached target tile or adjacent to the target dirt
        if (curr.x === targetX && curr.y === targetY) return path.slice(1);
        if (!world[targetY][targetX].mined && Math.abs(curr.x - targetX) + Math.abs(curr.y - targetY) === 1) {
            return path.slice(1);
        }

        // Define neighbors with your specific movement priorities
        let neighbors = [
            {x: curr.x, y: curr.y - 1, straightUp: true}, // Check UP first
            {x: curr.x + 1, y: curr.y},                   // Right
            {x: curr.x - 1, y: curr.y},                   // Left
            {x: curr.x, y: curr.y + 1},                   // Down
            {x: curr.x + 1, y: curr.y - 1, diag: true},   // Diagonal Up-Right
            {x: curr.x - 1, y: curr.y - 1, diag: true}    // Diagonal Up-Left
        ];

       for (let n of neighbors) {
    let id = `${n.x},${n.y}`;
    if (n.x >= 0 && n.x < COLS && n.y >= 0 && n.y < ROWS && !visited.has(id)) {
        let block = world[n.y][n.x];
        let canMove = block.mined; // Only move through air/mined tiles

        const currentTile = world[curr.y][curr.x];

        if (n.straightUp) {
            // Rule: Straight up is only for ladders
            if (!currentTile.hasLadder && !block.hasLadder) {
                canMove = false;
            }
        } else if (n.diag) {
            // --- TIGHTENED JUMP RULES ---
            // 1. Destination must have ground OR a ladder to land on
            let hasLedge = (n.y + 1 < ROWS) && !world[n.y + 1][n.x].mined;
            let targetHasLadder = block.hasLadder || ((n.y + 1 < ROWS) && world[n.y + 1][n.x].hasLadder);
            
            // 2. NEW: Prevent "Long Jumps" by checking if the source tile is a valid push-off point
            // The character must be standing on ground or a ladder to jump diagonally
            let sourceHasFloor = (curr.y + 1 < ROWS) && (!world[curr.y + 1][curr.x].mined || world[curr.y + 1][curr.x].hasLadder);
            let sourceIsLadder = currentTile.hasLadder;

            if (!canMove || (!hasLedge && !targetHasLadder) || (!sourceHasFloor && !sourceIsLadder)) {
                canMove = false;
            }
        }

        if (canMove) {
            visited.add(id);
            queue.push([...path, n]);
        }
    }
}
    }
    return []; // No path found
}


let blockedMessage = "";
let blockedTimer = 0;

function move() {
    if (currentPath.length > 0) {
        let nextStep = currentPath.shift();
        
        // Update facing
        if (nextStep.x > player.x) player.facing = 1;
        if (nextStep.x < player.x) player.facing = -1;

        player.x = nextStep.x;
        player.y = nextStep.y;

        // Determine animation state
        const onLadder = world[player.y][player.x].hasLadder;
        player.state = onLadder ? 'climb' : 'walk';

        // --- FIXED AUTO-SELL LOGIC ---
        if (player.y === 0 && player.cargo > 0) {
            let payout = player.cargoValue || 0;
            
            // Prepare the breakdown text
            let breakdown = `
                üü´ Dirt x${player.dirtCount || 0}: $${(player.dirtCount || 0) * 5}<br>
                üü° Gold x${player.goldCount || 0}: $${(player.goldCount || 0) * 25}<br>
                üíé Gems x${player.gemCount || 0}: $${(player.gemCount || 0) * 100}
            `;
            
            document.getElementById('saleBreakdown').innerHTML = breakdown;
            document.getElementById('totalSaleVal').innerText = `$${payout}`;
            document.getElementById('saleModal').style.display = 'flex';

            player.gold += payout;
            
            // Reset everything
            player.cargo = 0;
            player.cargoValue = 0;
            player.dirtCount = 0;
            player.goldCount = 0;
            player.gemCount = 0;
            
            currentPath = []; 
            player.state = 'idle';
            save();
            updateMiniMap(); 
            updateUI();
        }
    } else {
        // We reached the destination! Check if there's a block to mine
        if (player.queuedMine) {
            const q = player.queuedMine;
            // Ensure we are actually next to it now
            if (Math.abs(q.x - player.x) <= 1 && Math.abs(q.y - player.y) <= 1) {
                if (player.cargo < player.maxCargo) {
                    mineBlock(q.x, q.y);
                    updateUI();
                } else {
                    blockedMessage = "CARGO FULL!";
                    blockedTimer = 60;
                }
            }
            player.queuedMine = null; // Always clear the queue after arrival
        }

        if (player.state !== 'mine') {
            player.state = 'idle';
        }
    }
    updateUI();
}


function applyGravity() {
    if (player.y < ROWS - 1) {
        let current = world[player.y][player.x];
        let below = world[player.y + 1][player.x];
        
        // NEW PHYSICS: Fall ONLY if current tile NO ladder AND tile below NO ladder AND tile below is mined
        if (!current.hasLadder && !below.hasLadder && below.mined) {
            player.y++;
        }
    }
}

function mineBlock(x, y) {
    let b = world[y][x];
    if (b.type === 'bedrock') { nextLevel(); return; }

    if (x > player.x) player.facing = 1;
    if (x < player.x) player.facing = -1;

    player.state = 'mine';
    b.hp -= player.drillPower;

    if (b.hp <= 0) {
        b.mined = true;
        player.state = 'idle';
        player.cargo++;
        
        if (b.type === 'gem') {
            player.gemCount = (player.gemCount || 0) + 1;
            player.cargoValue += 100;
        } else if (b.type === 'gold') {
            player.goldCount = (player.goldCount || 0) + 1;
            player.cargoValue += 25;
        } else {
            player.dirtCount = (player.dirtCount || 0) + 1;
            player.cargoValue += 5;
        }
    }
    save(); updateMiniMap(); updateUI();
}

function openDropModal() {
    const container = document.getElementById('dropInputsContainer');
    container.innerHTML = ''; // Clear old inputs

    const items = [
        { id: 'dropDirt', label: 'üü´ Dirt', count: player.dirtCount || 0 },
        { id: 'dropGold', label: 'üü° Gold', count: player.goldCount || 0 },
        { id: 'dropGem', label: 'üíé Gem', count: player.gemCount || 0 }
    ];

    items.forEach(item => {
        if (item.count > 0) {
            const div = document.createElement('div');
            div.style.marginBottom = "10px";
            div.innerHTML = `
                <label style="display:block; font-size:0.9rem;">${item.label} (Max: ${item.count})</label>
                <input type="number" id="${item.id}" value="0" min="0" max="${item.count}" 
                style="width:100%; box-sizing:border-box; padding:8px; background:#333; color:white; border:1px solid #555;">
            `;
            container.appendChild(div);
        }
    });

    document.getElementById('dropModal').style.display = 'flex';
}

function closeDropModal() {
    document.getElementById('dropModal').style.display = 'none';
}

function confirmDrop() {
    const dAmount = parseInt(document.getElementById('dropDirt')?.value || 0);
    const gAmount = parseInt(document.getElementById('dropGold')?.value || 0);
    const mAmount = parseInt(document.getElementById('dropGem')?.value || 0);
    
    const totalToDrop = dAmount + gAmount + mAmount;
    if (totalToDrop <= 0) { closeDropModal(); return; }

    const tile = world[player.y][player.x];
    tile.hasCrate = true;
    
    // Initialize crate contents if empty
    if (!tile.crateContents) tile.crateContents = { dirt: 0, gold: 0, gem: 0 };
    
    // Add items to crate
    tile.crateContents.dirt += dAmount;
    tile.crateContents.gold += gAmount;
    tile.crateContents.gem += mAmount;
    tile.crateAmount = (tile.crateAmount || 0) + totalToDrop;

    // Remove from player
    player.cargo -= totalToDrop;
    player.dirtCount -= dAmount;
    player.goldCount -= gAmount;
    player.gemCount -= mAmount;
    player.cargoValue -= (dAmount * 5 + gAmount * 25 + mAmount * 100);

    closeDropModal();
    save(); updateMiniMap(); updateUI();
}

function closeSaleModal() {
    document.getElementById('saleModal').style.display = 'none';
}

// --- RENDERING ---
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let offsetY = Math.max(0, (player.y * TILE_SIZE) - canvas.height / 2);
    // Calculate the automatic camera target (centered on player)
let targetOffsetY = Math.max(0, (player.y * TILE_SIZE) - canvas.height / 2);

if (isManualScrolling) {
    // Smoothly transition or jump to the manual position
    offsetY = manualOffsetY;
} else {
    // Smoothly pan back to the player
    offsetY += (targetOffsetY - offsetY) * 0.1;
    manualOffsetY = offsetY; // Keep manual offset synced
}

    // --- FIX: Define onLadder by checking the world at player's current tile ---
    const onLadder = world[player.y] && world[player.y][player.x] ? world[player.y][player.x].hasLadder : false;

    // 1. Draw World (Blocks and Ladders)
for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
        let b = world[y][x];
        let rx = x * TILE_SIZE;
        let ry = (y * TILE_SIZE) - offsetY;

        // Performance: skip off-screen tiles
        if (ry < -TILE_SIZE || ry > canvas.height) continue;

        // --- STEP 1: DEFINE REVEALED FOR EVERY TILE ---
        let revealed = false;
        if (!b.mined) {
            for(let ty = -1; ty <= 1; ty++) {
                for(let tx = -1; tx <= 1; tx++) {
                    if(world[y + ty] && world[y + ty][x + tx] && world[y + ty][x + tx].mined) {
                        revealed = true;
                    }
                }
            }
        }

        // --- STEP 2: DRAW THE BLOCKS ---
        if (!b.mined) {
            let tileIndex = 0; // Default: Dirt
            if (revealed) {
                if (b.type === 'gold') tileIndex = 1;
                else if (b.type === 'gem') tileIndex = 2;
            }
            if (b.type === 'bedrock') tileIndex = 3;

            if (tileSprite.complete) {
                const sw = 909 / 4;
                ctx.drawImage(tileSprite, tileIndex * sw, 0, sw, 210, rx, ry, TILE_SIZE, TILE_SIZE);
            }

            // --- SPARKLE EFFECT (Now inside the block logic where it can see 'revealed') ---
            if (revealed && (b.type === 'gold' || b.type === 'gem')) {
                let blink = Math.sin(Date.now() / 200); 
                if (blink > 0.8) {
                    ctx.save();
                    ctx.translate(rx + TILE_SIZE/2, ry + TILE_SIZE/2);
                    ctx.rotate((Date.now() / 500) % (Math.PI * 2));
                    ctx.strokeStyle = b.type === 'gold' ? "#FFF59D" : "#A5D6A7";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-5, 0); ctx.lineTo(5, 0);
                    ctx.moveTo(0, -5); ctx.lineTo(0, 5);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // --- CRACKING EFFECT ---
            if (b.hp < b.maxHP) {
                ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
                ctx.lineWidth = 3;
                let pct = b.hp / b.maxHP;
                ctx.beginPath();
                if (pct < 0.9) { ctx.moveTo(rx+5, ry+5); ctx.lineTo(rx+15, ry+20); }
                if (pct < 0.6) { ctx.moveTo(rx+TILE_SIZE-5, ry+5); ctx.lineTo(rx+18, ry+22); }
                if (pct < 0.3) { ctx.moveTo(rx+5, ry+TILE_SIZE-5); ctx.lineTo(rx+22, ry+12); }
                ctx.stroke();
            }
        } else {
            // --- MINED AREA ---
            if (tileSprite.complete) {
                ctx.globalAlpha = 0.15;
                ctx.drawImage(tileSprite, 0, 0, 227, 210, rx, ry, TILE_SIZE, TILE_SIZE);
                ctx.globalAlpha = 1.0;
            }

            if (b.hasLadder) {
                if (ladderSprite.complete) {
                    ctx.drawImage(ladderSprite, 0, 0, 231, 417, rx, ry, TILE_SIZE, TILE_SIZE);
                } else {
                    ctx.strokeStyle = "#f39c12"; 
                    ctx.lineWidth = 4;
                    ctx.strokeRect(rx + 8, ry, TILE_SIZE - 16, TILE_SIZE);
                }
            }

            // Draw Dirt Crates
if (b.hasCrate) {
    ctx.fillStyle = "#5d4037";
    ctx.strokeStyle = "#3e2723";
    ctx.lineWidth = 2;
    ctx.fillRect(rx + 10, ry + 15, TILE_SIZE - 20, TILE_SIZE - 20);
    ctx.strokeRect(rx + 10, ry + 15, TILE_SIZE - 20, TILE_SIZE - 20);
    
    // Draw amount label
    ctx.fillStyle = "white";
    ctx.font = "bold 10px sans-serif";
    ctx.fillText(b.crateAmount, rx + 15, ry + 30);
}
        }
    }
}

   // --- DRAW STATIC GHOST AND DOTTED PATH ---
    if (currentPath.length > 0) {
        ctx.save();
        ctx.setLineDash([5, 5]); 
        ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        ctx.moveTo(player.x * TILE_SIZE + TILE_SIZE/2, (player.y * TILE_SIZE + TILE_SIZE/2) - offsetY);

        currentPath.forEach((step, index) => {
            let sx = step.x * TILE_SIZE + TILE_SIZE/2;
            let sy = (step.y * TILE_SIZE + TILE_SIZE/2) - offsetY;
            ctx.lineTo(sx, sy);

            // Draw Ghost Sprite at the very last step
            if (index === currentPath.length - 1) {
                ctx.globalAlpha = 0.4; 

                // Determine which way the ghost should face based on its arrival
                let lastStep = currentPath[currentPath.length - 1];
                let prevStep = currentPath.length > 1 ? currentPath[currentPath.length - 2] : player;
                let ghostFacing = (lastStep.x >= prevStep.x) ? 1 : -1;

                // Call drawStaticPlayer to keep the ghost from moving/climbing
                drawStaticPlayer(ctx, step.x * TILE_SIZE, (step.y * TILE_SIZE) - offsetY, ghostFacing, lastStep.y, lastStep.x);
                
                ctx.globalAlpha = 1.0;
            }
        });
        ctx.stroke();
        ctx.restore();
    }

    // Draw pixel player
    if (currentPath.length === 0 && player.state !== 'mine') {
        player.state = 'idle';
    }

    let playerRX = player.x * TILE_SIZE;
    let playerRY = (player.y * TILE_SIZE) - offsetY;
    drawPlayer(ctx, playerRX, playerRY); // This triggers your sprite logic!

    // 2. Draw Player (square)
    // ctx.fillStyle = '#0000FF';
    // ctx.fillRect(player.x * TILE_SIZE + 5, (player.y * TILE_SIZE) - offsetY + 5, TILE_SIZE - 10, TILE_SIZE - 10);

    // 3. --- NEW LINEAR DEPTH DARKNESS ---
    // 3. --- DYNAMIC DIRECTIONAL HEADLAMP ---
// 3. --- DYNAMIC HEADLAMP (TRUE BRIGHTNESS CENTER) ---
const px = player.x * TILE_SIZE + TILE_SIZE / 2;
const py = (player.y * TILE_SIZE + TILE_SIZE / 2) - offsetY;

// Only apply darkness if we are below the surface
if (player.y > 1) {
    ctx.save();
    
    // Position the light at the miner's head, shifting it forward based on facing
    let lightX = px + (player.facing * 20); 
    let lightY = py - 10;
    
    // Use the player's lightRadius (upgradable in the shop)
    let radius = (player.lightRadius || 3) * TILE_SIZE;

    // Create a radial gradient that is TRANSPARENT in the middle and DARK at the edges
    let headlamp = ctx.createRadialGradient(
        lightX, lightY, TILE_SIZE * 0.5, // Inner circle (Perfectly clear)
        lightX, lightY, radius           // Outer circle (Fades to black)
    );

    // Calculate how dark it should be based on depth
    let maxDarkness = Math.min(1.0, (player.y / ROWS) * 1.5);

    // Add color stops: 0 alpha means 100% clear/bright
    headlamp.addColorStop(0, "rgba(0, 0, 0, 0)");   
    headlamp.addColorStop(0.3, "rgba(0, 0, 0, 0)"); 
    // Gradually fade into the depth-based darkness blanket
    headlamp.addColorStop(1, `rgba(0, 0, 0, ${maxDarkness})`);

    ctx.fillStyle = headlamp;
    
    // Fill the entire canvas with this "darkness blanket" that has a hole in it
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.restore();
} else {
    // Near surface: subtle ambient dimming
    ctx.fillStyle = "rgba(0, 0, 0, 0.15)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

    // 4. Draw Blocked Message Overlay
    if (blockedTimer > 0) {
        ctx.fillStyle = "rgba(255, 0, 0, 0.7)";
        ctx.fillRect(50, canvas.height / 2 - 30, 300, 60);
        ctx.fillStyle = "white";
        ctx.font = "bold 16px sans-serif";
        let textWidth = ctx.measureText(blockedMessage).width;
        ctx.fillText(blockedMessage, canvas.width / 2 - textWidth / 2, canvas.height / 2 + 5);
        blockedTimer--;
    }

    requestAnimationFrame(draw);
}

function drawStaticPlayer(ctx, rx, ry, facing, y, x) {
    const FRAME_W = 922 / 4; 
    const FRAME_H = 902 / 3; 
    
    // Check surroundings for the ghost's position to pick the right idle pose
    const onLadder = world[y] && world[y][x] ? world[y][x].hasLadder : false;
    const ladderBelow = (y + 1 < ROWS) && world[y + 1][x].hasLadder;

    // Ghost is always idle
    let row = (onLadder || ladderBelow) ? 0 : 1; 
    let col = 0; 

    ctx.save();
    ctx.translate(Math.floor(rx + TILE_SIZE / 2), Math.floor(ry + TILE_SIZE));
    
    // Only flip if it's the side-facing idle (Row 1)
    if (row === 1) {
        ctx.scale(facing, 1);
    }

    if (spriteImg.complete) {
        ctx.drawImage(
            spriteImg,
            Math.floor(col * FRAME_W), Math.floor(row * FRAME_H), 
            Math.floor(FRAME_W), Math.floor(FRAME_H),             
            Math.floor(-TILE_SIZE / 2), 
            Math.floor(-TILE_SIZE * 1.2), 
            TILE_SIZE, 
            Math.floor(TILE_SIZE * 1.2)
        );
    }
    ctx.restore();
}

function drawPlayer(ctx, rx, ry) {
    const FRAME_W = 922 / 4; 
    const FRAME_H = 902 / 3; 
    
    let col = 0;
    let row = 0;

    // 1. Check if the current tile has a ladder
    const onLadder = world[player.y] && world[player.y][player.x] ? world[player.y][player.x].hasLadder : false;

    // 2. Check if the tile BELOW has a ladder or is solid ground
    const ladderBelow = (player.y + 1 < ROWS) && world[player.y + 1][player.x].hasLadder;
    const solidBelow = (player.y + 1 < ROWS) && !world[player.y + 1][player.x].mined;

    // 3. Fall ONLY if there's no ladder here, no ladder below, and no ground below
    const isFalling = (player.y < ROWS - 1) && !onLadder && !ladderBelow && !solidBelow;

    // --- ANIMATION LOGIC ---
    if (player.state === 'climb') {
        row = 2;
        col = (Math.floor(Date.now() / 200) % 2) + 1; 
    } 
    else if (isFalling) {
        // Falling: Frame 0,3 (Arms up)
        row = 0;
        col = 3; 
    }
    else if (player.state === 'walk') {
        row = 1;
        col = (Math.floor(Date.now() / 150) % 3) + 1; 
    } 
    else if (player.state === 'mine') {
        row = 0; 
        col = (Math.floor(Date.now() / 100) % 2) + 1;
    } 
    else {
        // IDLE STATES: 
        // If we are touching a ladder (here or below), show the front idle
        if (onLadder || ladderBelow) {
            row = 0; col = 0; // Front-facing "Ladder" Idle
        } else {
            row = 1; col = 0; // Side-facing "Ground" Idle
        }
    }

    ctx.save();
    ctx.translate(Math.floor(rx + TILE_SIZE / 2), Math.floor(ry + TILE_SIZE));
    
    // Don't flip the front-facing (0,0) or back-facing (2,0) frames
    if (!(row === 0 && col === 0) && !(row === 2 && col === 0)) {
        ctx.scale(player.facing || 1, 1);
    }

    if (spriteImg.complete) {
        ctx.drawImage(
            spriteImg,
            Math.floor(col * FRAME_W), Math.floor(row * FRAME_H), 
            Math.floor(FRAME_W), Math.floor(FRAME_H),             
            Math.floor(-TILE_SIZE / 2), 
            Math.floor(-TILE_SIZE * 1.2), 
            TILE_SIZE, 
            Math.floor(TILE_SIZE * 1.2)
        );
    }
    ctx.restore();
}

function toggleMap() {
    const map = document.getElementById('mapContainer');
    map.style.display = (map.style.display === 'none') ? 'block' : 'none';
    if(map.style.display === 'block') updateMiniMap();
}

function updateMiniMap() {
    const mCanvas = document.getElementById('mapCanvas');
    const mCtx = mCanvas.getContext('2d');
    const pSize = 4; // Pixel size on map

    mCtx.clearRect(0, 0, mCanvas.width, mCanvas.height);

    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
            let tile = world[y][x];
            let mx = x * pSize;
            let my = y * pSize;

            if (!tile.mined) {
                mCtx.fillStyle = "#332211"; // Unmined dirt
            } else {
                mCtx.fillStyle = "#111"; // Mined path
                if (tile.hasLadder) mCtx.fillStyle = "#f39c12"; // Ladders
                if (tile.hasCrate) mCtx.fillStyle = "#2ecc71";  // CRATES (Bright Green)
            }
            mCtx.fillRect(mx, my, pSize, pSize);
        }
    }

    // Draw Player dot
    mCtx.fillStyle = "white";
    mCtx.fillRect(player.x * pSize, player.y * pSize, pSize, pSize);
    
    // Auto-scroll the map to follow the player
    const mapContainer = document.getElementById('mapContainer');
    mapContainer.scrollTop = (player.y * pSize) - (mapContainer.offsetHeight / 2);
}

// --- LISTENERS ---
canvas.addEventListener('mousedown', e => handleInput(e.clientX, e.clientY));
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    isManualScrolling = true;
    
    // Adjust manual offset based on scroll wheel direction
    manualOffsetY += e.deltaY;

    // Clamp the scroll so you don't go above the surface or below the world
    const maxScroll = (ROWS * TILE_SIZE) - canvas.height;
    manualOffsetY = Math.max(0, Math.min(manualOffsetY, maxScroll));

    // Clear previous timeout and set a new one to return to player after 3 seconds of inactivity
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => { isManualScrolling = false; }, 3000);
}, { passive: false });

canvas.addEventListener('touchstart', e => {
    // Record where the touch began
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
}, { passive: true }); // Passive: true allows the browser to scroll immediately

let lastTouchY = 0;

canvas.addEventListener('touchmove', e => {
    if (e.touches.length === 2) {
        e.preventDefault();
        isManualScrolling = true;

        // Calculate the center Y of the two fingers
        let currentTouchY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        
        if (lastTouchY !== 0) {
            let dy = lastTouchY - currentTouchY;
            manualOffsetY += dy * 1.5; // Multiplier for scroll speed
        }
        lastTouchY = currentTouchY;

        const maxScroll = (ROWS * TILE_SIZE) - canvas.height;
        manualOffsetY = Math.max(0, Math.min(manualOffsetY, maxScroll));

        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => { isManualScrolling = false; }, 3000);
    }
}, { passive: false });

canvas.addEventListener('touchend', e => {
    // Get where the touch ended
    const touchEndX = e.changedTouches[0].clientX;
    const touchEndY = e.changedTouches[0].clientY;
    lastTouchY = 0; // Reset for next gesture

    // Calculate distance moved
    const dx = Math.abs(touchEndX - touchStartX);
    const dy = Math.abs(touchEndY - touchStartY);

    // If the movement is less than our threshold, it's a CLICK
    if (dx < SCROLL_THRESHOLD && dy < SCROLL_THRESHOLD) {
        // Stop the browser from doing anything else (like zooming)
        if (e.cancelable) e.preventDefault();
        
        // Run your game input logic
        handleInput(touchEndX, touchEndY);
    } 
    // Otherwise, we do nothing and let the browser continue the scroll
}, { passive: false });



function buyUpgrade(t) {
    if (t === 'cargo' && player.gold >= 100) { player.gold -= 100; player.maxCargo += 5; }
    else if (t === 'drill' && player.gold >= 150) { player.gold -= 150; player.drillPower += 1; }
    else if (t === 'ladders' && player.gold >= 50) { player.gold -= 50; player.ladders += 5; }
    else if (t === 'light' && player.gold >= 200) { player.gold -= 200; player.lightRadius += 1; } // New
    save(); updateUI();
}

function nextLevel() {
    // Calculate final haul value before descending
    const haulValue = player.cargoValue || 0;
    
    if (confirm(`Found Bedrock! You have $${haulValue} in cargo. Sell and descend to Level ${player.level + 1}?`)) {
        // Cash out/Pay the player
        player.gold += haulValue;
        // Reset the bag
        player.cargo = 0;
        player.cargoValue = 0;
        
        // Advance level. Increment and reset position
        player.level++;
        player.y = 0; // Reset player to the surface
        
        // Wipe old world data and generate new. CRITICAL: Clear the old world so the new HP scaling kicks in
        localStorage.removeItem('miner_world_data');
        // Re-initialize and Save
        initLevel();
        save();
        updateUI();
    }
}

function updateUI() {
    document.getElementById('goldDisplay').innerText = player.gold;
    document.getElementById('cargoDisplay').innerText = player.cargo;
    document.getElementById('lvlDisplay').innerText = player.level;
    document.getElementById('maxDisplay').innerText = player.maxCargo;
    document.getElementById('matDisplay').innerText = player.ladders;
    // Update depth (y coordinate * some multiplier)
    document.getElementById('depthDisplay').innerText = player.y;
}

initLevel();
setInterval(() => {
    move();
    // Only update the map if the player can actually see it
    if (document.getElementById('mapContainer').style.display === 'block') {
        updateMiniMap();
    }
}, 120);
setInterval(applyGravity, 300);
draw();
</script>
</body>

</html>















